// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: BitcoinV2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import VSwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of VSwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: VSwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: VSwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum TW_BitcoinV2_Proto_InputSelector: VSwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Automatically select enough inputs in an ascending order to cover the outputs of the transaction.
  case selectAscending // = 0

  /// Automatically select enough inputs in the given order to cover the outputs of the transaction.
  case selectInOrder // = 1

  /// Automatically select enough inputs in an descending order to cover the outputs of the transaction.
  case selectDescending // = 2

  /// Use all the inputs provided in the given order.
  case useAll // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .selectAscending
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .selectAscending
    case 1: self = .selectInOrder
    case 2: self = .selectDescending
    case 10: self = .useAll
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .selectAscending: return 0
    case .selectInOrder: return 1
    case .selectDescending: return 2
    case .useAll: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TW_BitcoinV2_Proto_InputSelector: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_BitcoinV2_Proto_InputSelector] = [
    .selectAscending,
    .selectInOrder,
    .selectDescending,
    .useAll,
  ]
}

#endif  // swift(>=4.2)

public enum TW_BitcoinV2_Proto_TransactionVersion: VSwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// V1 is used by default.
  case useDefault // = 0

  /// Original transaction version.
  case v1 // = 1

  /// https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki#specification
  case v2 // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .useDefault
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .useDefault
    case 1: self = .v1
    case 2: self = .v2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .useDefault: return 0
    case .v1: return 1
    case .v2: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TW_BitcoinV2_Proto_TransactionVersion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_BitcoinV2_Proto_TransactionVersion] = [
    .useDefault,
    .v1,
    .v2,
  ]
}

#endif  // swift(>=4.2)

/// Either a public key or public key hash.
public struct TW_BitcoinV2_Proto_PublicKeyOrHash {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  public var variant: TW_BitcoinV2_Proto_PublicKeyOrHash.OneOf_Variant? = nil

  /// Public key bytes.
  public var pubkey: Data {
    get {
      if case .pubkey(let v)? = variant {return v}
      return Data()
    }
    set {variant = .pubkey(newValue)}
  }

  /// Public key hash.
  public var hash: Data {
    get {
      if case .hash(let v)? = variant {return v}
      return Data()
    }
    set {variant = .hash(newValue)}
  }

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  public enum OneOf_Variant: Equatable {
    /// Public key bytes.
    case pubkey(Data)
    /// Public key hash.
    case hash(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_PublicKeyOrHash.OneOf_Variant, rhs: TW_BitcoinV2_Proto_PublicKeyOrHash.OneOf_Variant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pubkey, .pubkey): return {
        guard case .pubkey(let l) = lhs, case .pubkey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hash, .hash): return {
        guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Public key and corresponding signature.
public struct TW_BitcoinV2_Proto_PublicKeySignature {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  /// Public key bytes. Type of the public key depends on the context.
  public var publicKey: Data = Data()

  /// Signature 64-length byte array.
  public var signature: Data = Data()

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_BitcoinV2_Proto_Input {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to the previous transaction's output.
  public var outPoint: TW_Utxo_Proto_OutPoint {
    get {return _outPoint ?? TW_Utxo_Proto_OutPoint()}
    set {_outPoint = newValue}
  }
  /// Returns true if `outPoint` has been explicitly set.
  public var hasOutPoint: Bool {return self._outPoint != nil}
  /// Clears the value of `outPoint`. Subsequent reads from it will return its default value.
  public mutating func clearOutPoint() {self._outPoint = nil}

  /// The amount of satoshis of this input.
  public var value: Int64 = 0

  /// The sighash type, normally `All`.
  /// See `TWBitcoinSigHashType` enum.
  public var sighashType: UInt32 = 0

  /// Optional sequence number, used for timelocks, replace-by-fee, etc.
  /// Leave empty to use a default 4294967295 (0xFFFFFFFF) value.
  public var sequence: TW_BitcoinV2_Proto_Input.Sequence {
    get {return _sequence ?? TW_BitcoinV2_Proto_Input.Sequence()}
    set {_sequence = newValue}
  }
  /// Returns true if `sequence` has been explicitly set.
  public var hasSequence: Bool {return self._sequence != nil}
  /// Clears the value of `sequence`. Subsequent reads from it will return its default value.
  public mutating func clearSequence() {self._sequence = nil}

  /// Script for claiming this UTXO.
  public var claimingScript: TW_BitcoinV2_Proto_Input.OneOf_ClaimingScript? = nil

  /// Construct claiming script with a builder pattern.
  public var scriptBuilder: TW_BitcoinV2_Proto_Input.InputBuilder {
    get {
      if case .scriptBuilder(let v)? = claimingScript {return v}
      return TW_BitcoinV2_Proto_Input.InputBuilder()
    }
    set {claimingScript = .scriptBuilder(newValue)}
  }

  /// Spending script pubkey data.
  /// Use this variant if the UTXO claiming script is known already, otherwise use `InputBuilder`.
  /// Please note that the signing method (eg "legacy" or "segwit") will be determined by parsing the script data as:
  /// - P2PK, P2PKH - legacy signing method;
  /// - P2WPKH - segwit signing method.
  public var scriptData: Data {
    get {
      if case .scriptData(let v)? = claimingScript {return v}
      return Data()
    }
    set {claimingScript = .scriptData(newValue)}
  }

  /// Derive a spending script pubkey from a receiver address.
  /// E.g "bc1" segwit address will be P2WPKH claiming script.
  /// TODO consider deprecating this because we can't determine if the script pubkey is P2PK or P2PKH actually.
  public var receiverAddress: String {
    get {
      if case .receiverAddress(let v)? = claimingScript {return v}
      return String()
    }
    set {claimingScript = .receiverAddress(newValue)}
  }

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  /// Script for claiming this UTXO.
  public enum OneOf_ClaimingScript: Equatable {
    /// Construct claiming script with a builder pattern.
    case scriptBuilder(TW_BitcoinV2_Proto_Input.InputBuilder)
    /// Spending script pubkey data.
    /// Use this variant if the UTXO claiming script is known already, otherwise use `InputBuilder`.
    /// Please note that the signing method (eg "legacy" or "segwit") will be determined by parsing the script data as:
    /// - P2PK, P2PKH - legacy signing method;
    /// - P2WPKH - segwit signing method.
    case scriptData(Data)
    /// Derive a spending script pubkey from a receiver address.
    /// E.g "bc1" segwit address will be P2WPKH claiming script.
    /// TODO consider deprecating this because we can't determine if the script pubkey is P2PK or P2PKH actually.
    case receiverAddress(String)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_Input.OneOf_ClaimingScript, rhs: TW_BitcoinV2_Proto_Input.OneOf_ClaimingScript) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.scriptBuilder, .scriptBuilder): return {
        guard case .scriptBuilder(let l) = lhs, case .scriptBuilder(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scriptData, .scriptData): return {
        guard case .scriptData(let l) = lhs, case .scriptData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.receiverAddress, .receiverAddress): return {
        guard case .receiverAddress(let l) = lhs, case .receiverAddress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Optional sequence number, used for timelocks, replace-by-fee, etc.
  public struct Sequence {
    // VSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
    // methods supported on all messages.

    public var sequence: UInt32 = 0

    public var unknownFields = VSwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct InputBuilder {
    // VSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
    // methods supported on all messages.

    /// Pay-to-Script-Hash, specify the redeem script.
    /// Please note that we support standard redeem scripts only, such as P2PKH, P2WPKH, P2TR.
    /// TODO next iteration.
    /// bytes p2sh = 1;
    public var variant: TW_BitcoinV2_Proto_Input.InputBuilder.OneOf_Variant? = nil

    /// Pay-to-Public-Key, specify the public key.
    public var p2Pk: Data {
      get {
        if case .p2Pk(let v)? = variant {return v}
        return Data()
      }
      set {variant = .p2Pk(newValue)}
    }

    /// Pay-to-Public-Key-Hash, specify the public key.
    public var p2Pkh: TW_BitcoinV2_Proto_PublicKeyOrHash {
      get {
        if case .p2Pkh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_PublicKeyOrHash()
      }
      set {variant = .p2Pkh(newValue)}
    }

    /// Pay-to-Public-Key-Hash, specify the public key.
    public var p2Wpkh: TW_BitcoinV2_Proto_PublicKeyOrHash {
      get {
        if case .p2Wpkh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_PublicKeyOrHash()
      }
      set {variant = .p2Wpkh(newValue)}
    }

    /// Pay-to-Taproot-key-path (balance transfers), specify the public key.
    public var p2TrKeyPath: Data {
      get {
        if case .p2TrKeyPath(let v)? = variant {return v}
        return Data()
      }
      set {variant = .p2TrKeyPath(newValue)}
    }

    /// Create a BRC20 inscription.
    public var brc20Inscribe: TW_BitcoinV2_Proto_Input.InputBrc20Inscription {
      get {
        if case .brc20Inscribe(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_Input.InputBrc20Inscription()
      }
      set {variant = .brc20Inscribe(newValue)}
    }

    /// Spend a Staking Output via timelock path (staking time expired).
    /// In other words, create a Withdraw transaction.
    public var babylonStakingTimelockPath: TW_BabylonStaking_Proto_InputBuilder.StakingTimelockPath {
      get {
        if case .babylonStakingTimelockPath(let v)? = variant {return v}
        return TW_BabylonStaking_Proto_InputBuilder.StakingTimelockPath()
      }
      set {variant = .babylonStakingTimelockPath(newValue)}
    }

    /// Spend a Staking Output via unbonding path.
    /// In other words, create an Unbonding transaction.
    public var babylonStakingUnbondingPath: TW_BabylonStaking_Proto_InputBuilder.StakingUnbondingPath {
      get {
        if case .babylonStakingUnbondingPath(let v)? = variant {return v}
        return TW_BabylonStaking_Proto_InputBuilder.StakingUnbondingPath()
      }
      set {variant = .babylonStakingUnbondingPath(newValue)}
    }

    /// Spend a Staking Output via slashing path.
    /// In other words, generate an unsigned slashing transaction, pre-sign the staker's signature only and share to Babylon PoS chain.
    public var babylonStakingSlashingPath: TW_BabylonStaking_Proto_InputBuilder.StakingSlashingPath {
      get {
        if case .babylonStakingSlashingPath(let v)? = variant {return v}
        return TW_BabylonStaking_Proto_InputBuilder.StakingSlashingPath()
      }
      set {variant = .babylonStakingSlashingPath(newValue)}
    }

    /// Spend an Unbonding Output via timelock path (unbonding time expired).
    /// In other words, create a Withdraw transaction spending an Unbonding transaction.
    public var babylonUnbondingTimelockPath: TW_BabylonStaking_Proto_InputBuilder.UnbondingTimelockPath {
      get {
        if case .babylonUnbondingTimelockPath(let v)? = variant {return v}
        return TW_BabylonStaking_Proto_InputBuilder.UnbondingTimelockPath()
      }
      set {variant = .babylonUnbondingTimelockPath(newValue)}
    }

    /// Spend an Unbonding Output via slashing path.
    /// In other words, generate an unsigned Slashing transaction, pre-sign the staker's signature only and share to Babylon PoS chain.
    public var babylonUnbondingSlashingPath: TW_BabylonStaking_Proto_InputBuilder.UnbondingSlashingPath {
      get {
        if case .babylonUnbondingSlashingPath(let v)? = variant {return v}
        return TW_BabylonStaking_Proto_InputBuilder.UnbondingSlashingPath()
      }
      set {variant = .babylonUnbondingSlashingPath(newValue)}
    }

    public var unknownFields = VSwiftProtobuf.UnknownStorage()

    /// Pay-to-Script-Hash, specify the redeem script.
    /// Please note that we support standard redeem scripts only, such as P2PKH, P2WPKH, P2TR.
    /// TODO next iteration.
    /// bytes p2sh = 1;
    public enum OneOf_Variant: Equatable {
      /// Pay-to-Public-Key, specify the public key.
      case p2Pk(Data)
      /// Pay-to-Public-Key-Hash, specify the public key.
      case p2Pkh(TW_BitcoinV2_Proto_PublicKeyOrHash)
      /// Pay-to-Public-Key-Hash, specify the public key.
      case p2Wpkh(TW_BitcoinV2_Proto_PublicKeyOrHash)
      /// Pay-to-Taproot-key-path (balance transfers), specify the public key.
      case p2TrKeyPath(Data)
      /// Create a BRC20 inscription.
      case brc20Inscribe(TW_BitcoinV2_Proto_Input.InputBrc20Inscription)
      /// Spend a Staking Output via timelock path (staking time expired).
      /// In other words, create a Withdraw transaction.
      case babylonStakingTimelockPath(TW_BabylonStaking_Proto_InputBuilder.StakingTimelockPath)
      /// Spend a Staking Output via unbonding path.
      /// In other words, create an Unbonding transaction.
      case babylonStakingUnbondingPath(TW_BabylonStaking_Proto_InputBuilder.StakingUnbondingPath)
      /// Spend a Staking Output via slashing path.
      /// In other words, generate an unsigned slashing transaction, pre-sign the staker's signature only and share to Babylon PoS chain.
      case babylonStakingSlashingPath(TW_BabylonStaking_Proto_InputBuilder.StakingSlashingPath)
      /// Spend an Unbonding Output via timelock path (unbonding time expired).
      /// In other words, create a Withdraw transaction spending an Unbonding transaction.
      case babylonUnbondingTimelockPath(TW_BabylonStaking_Proto_InputBuilder.UnbondingTimelockPath)
      /// Spend an Unbonding Output via slashing path.
      /// In other words, generate an unsigned Slashing transaction, pre-sign the staker's signature only and share to Babylon PoS chain.
      case babylonUnbondingSlashingPath(TW_BabylonStaking_Proto_InputBuilder.UnbondingSlashingPath)

    #if !swift(>=4.1)
      public static func ==(lhs: TW_BitcoinV2_Proto_Input.InputBuilder.OneOf_Variant, rhs: TW_BitcoinV2_Proto_Input.InputBuilder.OneOf_Variant) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.p2Pk, .p2Pk): return {
          guard case .p2Pk(let l) = lhs, case .p2Pk(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Pkh, .p2Pkh): return {
          guard case .p2Pkh(let l) = lhs, case .p2Pkh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Wpkh, .p2Wpkh): return {
          guard case .p2Wpkh(let l) = lhs, case .p2Wpkh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2TrKeyPath, .p2TrKeyPath): return {
          guard case .p2TrKeyPath(let l) = lhs, case .p2TrKeyPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.brc20Inscribe, .brc20Inscribe): return {
          guard case .brc20Inscribe(let l) = lhs, case .brc20Inscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.babylonStakingTimelockPath, .babylonStakingTimelockPath): return {
          guard case .babylonStakingTimelockPath(let l) = lhs, case .babylonStakingTimelockPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.babylonStakingUnbondingPath, .babylonStakingUnbondingPath): return {
          guard case .babylonStakingUnbondingPath(let l) = lhs, case .babylonStakingUnbondingPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.babylonStakingSlashingPath, .babylonStakingSlashingPath): return {
          guard case .babylonStakingSlashingPath(let l) = lhs, case .babylonStakingSlashingPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.babylonUnbondingTimelockPath, .babylonUnbondingTimelockPath): return {
          guard case .babylonUnbondingTimelockPath(let l) = lhs, case .babylonUnbondingTimelockPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.babylonUnbondingSlashingPath, .babylonUnbondingSlashingPath): return {
          guard case .babylonUnbondingSlashingPath(let l) = lhs, case .babylonUnbondingSlashingPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct InputTaprootScriptPath {
    // VSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
    // methods supported on all messages.

    /// The payload of the Taproot transaction.
    public var payload: Data = Data()

    /// The control block of the Taproot transaction required for claiming.
    public var controlBlock: Data = Data()

    public var unknownFields = VSwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct InputBrc20Inscription {
    // VSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
    // methods supported on all messages.

    /// The recipient of the inscription, usually the sender.
    public var inscribeTo: Data = Data()

    /// The ticker of the BRC20 inscription.
    public var ticker: String = String()

    /// The BRC20 token transfer amount.
    public var transferAmount: String = String()

    public var unknownFields = VSwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _outPoint: TW_Utxo_Proto_OutPoint? = nil
  fileprivate var _sequence: TW_BitcoinV2_Proto_Input.Sequence? = nil
}

public struct TW_BitcoinV2_Proto_Output {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  /// The amount of satoshis to send.
  public var value: Int64 = 0

  public var toRecipient: TW_BitcoinV2_Proto_Output.OneOf_ToRecipient? = nil

  /// Construct output with builder pattern.
  public var builder: TW_BitcoinV2_Proto_Output.OutputBuilder {
    get {
      if case .builder(let v)? = toRecipient {return v}
      return TW_BitcoinV2_Proto_Output.OutputBuilder()
    }
    set {toRecipient = .builder(newValue)}
  }

  /// Construct output by providing the scriptPubkey directly.
  public var customScriptPubkey: Data {
    get {
      if case .customScriptPubkey(let v)? = toRecipient {return v}
      return Data()
    }
    set {toRecipient = .customScriptPubkey(newValue)}
  }

  /// Derive the expected output from the provided address.
  public var toAddress: String {
    get {
      if case .toAddress(let v)? = toRecipient {return v}
      return String()
    }
    set {toRecipient = .toAddress(newValue)}
  }

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  public enum OneOf_ToRecipient: Equatable {
    /// Construct output with builder pattern.
    case builder(TW_BitcoinV2_Proto_Output.OutputBuilder)
    /// Construct output by providing the scriptPubkey directly.
    case customScriptPubkey(Data)
    /// Derive the expected output from the provided address.
    case toAddress(String)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_Output.OneOf_ToRecipient, rhs: TW_BitcoinV2_Proto_Output.OneOf_ToRecipient) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.builder, .builder): return {
        guard case .builder(let l) = lhs, case .builder(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.customScriptPubkey, .customScriptPubkey): return {
        guard case .customScriptPubkey(let l) = lhs, case .customScriptPubkey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.toAddress, .toAddress): return {
        guard case .toAddress(let l) = lhs, case .toAddress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct OutputBuilder {
    // VSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
    // methods supported on all messages.

    public var variant: TW_BitcoinV2_Proto_Output.OutputBuilder.OneOf_Variant? = nil

    /// Pay-to-Script-Hash, specify the redeem script or its hash.
    public var p2Sh: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash {
      get {
        if case .p2Sh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_Output.RedeemScriptOrHash()
      }
      set {variant = .p2Sh(newValue)}
    }

    /// Pay-to-Public-Key, specify the public key.
    public var p2Pk: Data {
      get {
        if case .p2Pk(let v)? = variant {return v}
        return Data()
      }
      set {variant = .p2Pk(newValue)}
    }

    /// Pay-to-Public-Key-Hash, specify the public key or its hash.
    public var p2Pkh: TW_BitcoinV2_Proto_PublicKeyOrHash {
      get {
        if case .p2Pkh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_PublicKeyOrHash()
      }
      set {variant = .p2Pkh(newValue)}
    }

    /// Pay-to-Witness-Script-Hash, specify the redeem script or its hash.
    public var p2Wsh: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash {
      get {
        if case .p2Wsh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_Output.RedeemScriptOrHash()
      }
      set {variant = .p2Wsh(newValue)}
    }

    /// Pay-to-Public-Key-Hash, specify the public key or its hash.
    public var p2Wpkh: TW_BitcoinV2_Proto_PublicKeyOrHash {
      get {
        if case .p2Wpkh(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_PublicKeyOrHash()
      }
      set {variant = .p2Wpkh(newValue)}
    }

    /// Pay-to-Taproot-key-path (balance transfers), specify the public key.
    public var p2TrKeyPath: Data {
      get {
        if case .p2TrKeyPath(let v)? = variant {return v}
        return Data()
      }
      set {variant = .p2TrKeyPath(newValue)}
    }

    /// Pay-to-Taproot-script-path (complex transfers)
    public var p2TrScriptPath: TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath {
      get {
        if case .p2TrScriptPath(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath()
      }
      set {variant = .p2TrScriptPath(newValue)}
    }

    public var p2TrDangerousAssumeTweaked: Data {
      get {
        if case .p2TrDangerousAssumeTweaked(let v)? = variant {return v}
        return Data()
      }
      set {variant = .p2TrDangerousAssumeTweaked(newValue)}
    }

    public var brc20Inscribe: TW_BitcoinV2_Proto_Output.OutputBrc20Inscription {
      get {
        if case .brc20Inscribe(let v)? = variant {return v}
        return TW_BitcoinV2_Proto_Output.OutputBrc20Inscription()
      }
      set {variant = .brc20Inscribe(newValue)}
    }

    /// OP_RETURN output. In most cases, with a zero-amount.
    public var opReturn: Data {
      get {
        if case .opReturn(let v)? = variant {return v}
        return Data()
      }
      set {variant = .opReturn(newValue)}
    }

    /// Create a Babylon `Staking` output.
    public var babylonStaking: TW_BabylonStaking_Proto_OutputBuilder.StakingOutput {
      get {
        if case .babylonStaking(let v)? = variant {return v}
        return TW_BabylonStaking_Proto_OutputBuilder.StakingOutput()
      }
      set {variant = .babylonStaking(newValue)}
    }

    /// Create a Babylon `Unbonding` output.
    public var babylonUnbonding: TW_BabylonStaking_Proto_OutputBuilder.UnbondingOutput {
      get {
        if case .babylonUnbonding(let v)? = variant {return v}
        return TW_BabylonStaking_Proto_OutputBuilder.UnbondingOutput()
      }
      set {variant = .babylonUnbonding(newValue)}
    }

    /// Create a Babylon `Staking` OP_RETURN output.
    public var babylonStakingOpReturn: TW_BabylonStaking_Proto_OutputBuilder.OpReturn {
      get {
        if case .babylonStakingOpReturn(let v)? = variant {return v}
        return TW_BabylonStaking_Proto_OutputBuilder.OpReturn()
      }
      set {variant = .babylonStakingOpReturn(newValue)}
    }

    public var unknownFields = VSwiftProtobuf.UnknownStorage()

    public enum OneOf_Variant: Equatable {
      /// Pay-to-Script-Hash, specify the redeem script or its hash.
      case p2Sh(TW_BitcoinV2_Proto_Output.RedeemScriptOrHash)
      /// Pay-to-Public-Key, specify the public key.
      case p2Pk(Data)
      /// Pay-to-Public-Key-Hash, specify the public key or its hash.
      case p2Pkh(TW_BitcoinV2_Proto_PublicKeyOrHash)
      /// Pay-to-Witness-Script-Hash, specify the redeem script or its hash.
      case p2Wsh(TW_BitcoinV2_Proto_Output.RedeemScriptOrHash)
      /// Pay-to-Public-Key-Hash, specify the public key or its hash.
      case p2Wpkh(TW_BitcoinV2_Proto_PublicKeyOrHash)
      /// Pay-to-Taproot-key-path (balance transfers), specify the public key.
      case p2TrKeyPath(Data)
      /// Pay-to-Taproot-script-path (complex transfers)
      case p2TrScriptPath(TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath)
      case p2TrDangerousAssumeTweaked(Data)
      case brc20Inscribe(TW_BitcoinV2_Proto_Output.OutputBrc20Inscription)
      /// OP_RETURN output. In most cases, with a zero-amount.
      case opReturn(Data)
      /// Create a Babylon `Staking` output.
      case babylonStaking(TW_BabylonStaking_Proto_OutputBuilder.StakingOutput)
      /// Create a Babylon `Unbonding` output.
      case babylonUnbonding(TW_BabylonStaking_Proto_OutputBuilder.UnbondingOutput)
      /// Create a Babylon `Staking` OP_RETURN output.
      case babylonStakingOpReturn(TW_BabylonStaking_Proto_OutputBuilder.OpReturn)

    #if !swift(>=4.1)
      public static func ==(lhs: TW_BitcoinV2_Proto_Output.OutputBuilder.OneOf_Variant, rhs: TW_BitcoinV2_Proto_Output.OutputBuilder.OneOf_Variant) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.p2Sh, .p2Sh): return {
          guard case .p2Sh(let l) = lhs, case .p2Sh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Pk, .p2Pk): return {
          guard case .p2Pk(let l) = lhs, case .p2Pk(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Pkh, .p2Pkh): return {
          guard case .p2Pkh(let l) = lhs, case .p2Pkh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Wsh, .p2Wsh): return {
          guard case .p2Wsh(let l) = lhs, case .p2Wsh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2Wpkh, .p2Wpkh): return {
          guard case .p2Wpkh(let l) = lhs, case .p2Wpkh(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2TrKeyPath, .p2TrKeyPath): return {
          guard case .p2TrKeyPath(let l) = lhs, case .p2TrKeyPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2TrScriptPath, .p2TrScriptPath): return {
          guard case .p2TrScriptPath(let l) = lhs, case .p2TrScriptPath(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.p2TrDangerousAssumeTweaked, .p2TrDangerousAssumeTweaked): return {
          guard case .p2TrDangerousAssumeTweaked(let l) = lhs, case .p2TrDangerousAssumeTweaked(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.brc20Inscribe, .brc20Inscribe): return {
          guard case .brc20Inscribe(let l) = lhs, case .brc20Inscribe(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.opReturn, .opReturn): return {
          guard case .opReturn(let l) = lhs, case .opReturn(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.babylonStaking, .babylonStaking): return {
          guard case .babylonStaking(let l) = lhs, case .babylonStaking(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.babylonUnbonding, .babylonUnbonding): return {
          guard case .babylonUnbonding(let l) = lhs, case .babylonUnbonding(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.babylonStakingOpReturn, .babylonStakingOpReturn): return {
          guard case .babylonStakingOpReturn(let l) = lhs, case .babylonStakingOpReturn(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Either a redeem script or its hash.
  public struct RedeemScriptOrHash {
    // VSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
    // methods supported on all messages.

    public var variant: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash.OneOf_Variant? = nil

    /// Redeem script bytes.
    public var redeemScript: Data {
      get {
        if case .redeemScript(let v)? = variant {return v}
        return Data()
      }
      set {variant = .redeemScript(newValue)}
    }

    /// Public key hash.
    public var hash: Data {
      get {
        if case .hash(let v)? = variant {return v}
        return Data()
      }
      set {variant = .hash(newValue)}
    }

    public var unknownFields = VSwiftProtobuf.UnknownStorage()

    public enum OneOf_Variant: Equatable {
      /// Redeem script bytes.
      case redeemScript(Data)
      /// Public key hash.
      case hash(Data)

    #if !swift(>=4.1)
      public static func ==(lhs: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash.OneOf_Variant, rhs: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash.OneOf_Variant) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.redeemScript, .redeemScript): return {
          guard case .redeemScript(let l) = lhs, case .redeemScript(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.hash, .hash): return {
          guard case .hash(let l) = lhs, case .hash(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct OutputTaprootScriptPath {
    // VSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
    // methods supported on all messages.

    /// The internal key, usually the public key of the recipient.
    public var internalKey: Data = Data()

    /// The merkle root of the Taproot script(s), required to compute the sighash.
    public var merkleRoot: Data = Data()

    public var unknownFields = VSwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct OutputBrc20Inscription {
    // VSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
    // methods supported on all messages.

    /// The recipient of the inscription, usually the sender.
    public var inscribeTo: Data = Data()

    /// The ticker of the BRC20 inscription.
    public var ticker: String = String()

    /// The BRC20 token transfer amount.
    public var transferAmount: String = String()

    public var unknownFields = VSwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct TW_BitcoinV2_Proto_ChainInfo {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  /// P2PKH prefix for this chain.
  public var p2PkhPrefix: UInt32 = 0

  /// P2SH prefix for this coin type.
  public var p2ShPrefix: UInt32 = 0

  /// HRP for this coin type if applicable.
  public var hrp: String = String()

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Transaction builder used in `SigningInput`.
public struct TW_BitcoinV2_Proto_TransactionBuilder {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  /// Transaction version.
  public var version: TW_BitcoinV2_Proto_TransactionVersion {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// (optional) Block height or timestamp indicating at what point transactions can be included in a block.
  /// Zero by default.
  public var lockTime: UInt32 {
    get {return _storage._lockTime}
    set {_uniqueStorage()._lockTime = newValue}
  }

  /// The inputs to spend.
  public var inputs: [TW_BitcoinV2_Proto_Input] {
    get {return _storage._inputs}
    set {_uniqueStorage()._inputs = newValue}
  }

  /// The output of the transaction. Note that the change output is specified
  /// in the `change_output` field.
  public var outputs: [TW_BitcoinV2_Proto_Output] {
    get {return _storage._outputs}
    set {_uniqueStorage()._outputs = newValue}
  }

  /// How the inputs should be selected.
  public var inputSelector: TW_BitcoinV2_Proto_InputSelector {
    get {return _storage._inputSelector}
    set {_uniqueStorage()._inputSelector = newValue}
  }

  /// The amount of satoshis per vbyte ("satVb"), used for fee calculation.
  /// Can be satoshis per byte ("satB") **ONLY** when transaction does not contain segwit UTXOs.
  public var feePerVb: Int64 {
    get {return _storage._feePerVb}
    set {_uniqueStorage()._feePerVb = newValue}
  }

  /// (optional) The change output to be added (return to sender) at the end of the outputs list.
  /// The `Output.value` will be overwritten, leave default.
  /// Note there can be no change output if the change amount is less than dust threshold.
  /// Leave empty to explicitly disable change output creation.
  public var changeOutput: TW_BitcoinV2_Proto_Output {
    get {return _storage._changeOutput ?? TW_BitcoinV2_Proto_Output()}
    set {_uniqueStorage()._changeOutput = newValue}
  }
  /// Returns true if `changeOutput` has been explicitly set.
  public var hasChangeOutput: Bool {return _storage._changeOutput != nil}
  /// Clears the value of `changeOutput`. Subsequent reads from it will return its default value.
  public mutating func clearChangeOutput() {_uniqueStorage()._changeOutput = nil}

  /// The only output with a max available amount to be send.
  /// If set, `SigningInput.outputs` and `SigningInput.change` will be ignored.
  /// The `Output.value` will be overwritten, leave default.
  public var maxAmountOutput: TW_BitcoinV2_Proto_Output {
    get {return _storage._maxAmountOutput ?? TW_BitcoinV2_Proto_Output()}
    set {_uniqueStorage()._maxAmountOutput = newValue}
  }
  /// Returns true if `maxAmountOutput` has been explicitly set.
  public var hasMaxAmountOutput: Bool {return _storage._maxAmountOutput != nil}
  /// Clears the value of `maxAmountOutput`. Subsequent reads from it will return its default value.
  public mutating func clearMaxAmountOutput() {_uniqueStorage()._maxAmountOutput = nil}

  /// One of the "Dust" amount policies.
  /// Later, we plan to add support for `DynamicDust` policy with a `min_relay_fee` amount.
  public var dustPolicy: OneOf_DustPolicy? {
    get {return _storage._dustPolicy}
    set {_uniqueStorage()._dustPolicy = newValue}
  }

  /// Use a constant "Dust" threshold.
  public var fixedDustThreshold: Int64 {
    get {
      if case .fixedDustThreshold(let v)? = _storage._dustPolicy {return v}
      return 0
    }
    set {_uniqueStorage()._dustPolicy = .fixedDustThreshold(newValue)}
  }

  public var chainSpecific: OneOf_ChainSpecific? {
    get {return _storage._chainSpecific}
    set {_uniqueStorage()._chainSpecific = newValue}
  }

  /// ZCash specific transaction data.
  public var zcashExtraData: TW_Zcash_Proto_TransactionBuilderExtraData {
    get {
      if case .zcashExtraData(let v)? = _storage._chainSpecific {return v}
      return TW_Zcash_Proto_TransactionBuilderExtraData()
    }
    set {_uniqueStorage()._chainSpecific = .zcashExtraData(newValue)}
  }

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  /// One of the "Dust" amount policies.
  /// Later, we plan to add support for `DynamicDust` policy with a `min_relay_fee` amount.
  public enum OneOf_DustPolicy: Equatable {
    /// Use a constant "Dust" threshold.
    case fixedDustThreshold(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_TransactionBuilder.OneOf_DustPolicy, rhs: TW_BitcoinV2_Proto_TransactionBuilder.OneOf_DustPolicy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.fixedDustThreshold, .fixedDustThreshold): return {
        guard case .fixedDustThreshold(let l) = lhs, case .fixedDustThreshold(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum OneOf_ChainSpecific: Equatable {
    /// ZCash specific transaction data.
    case zcashExtraData(TW_Zcash_Proto_TransactionBuilderExtraData)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_TransactionBuilder.OneOf_ChainSpecific, rhs: TW_BitcoinV2_Proto_TransactionBuilder.OneOf_ChainSpecific) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.zcashExtraData, .zcashExtraData): return {
        guard case .zcashExtraData(let l) = lhs, case .zcashExtraData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Partially Signed Bitcoin Transaction.
public struct TW_BitcoinV2_Proto_Psbt {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  /// Partially Signed Bitcoin Transaction binary encoded.
  public var psbt: Data = Data()

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_BitcoinV2_Proto_SigningInput {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  /// User private keys.
  /// Only required if the `sign` method is called.
  public var privateKeys: [Data] = []

  /// User public keys.
  /// Only required if the `plan`, `preImageHash` methods are called.
  public var publicKeys: [Data] = []

  /// Chain info includes p2pkh, p2sh address prefixes.
  /// The parameter needs to be set if an input/output has a receiver address pattern.
  public var chainInfo: TW_BitcoinV2_Proto_ChainInfo {
    get {return _chainInfo ?? TW_BitcoinV2_Proto_ChainInfo()}
    set {_chainInfo = newValue}
  }
  /// Returns true if `chainInfo` has been explicitly set.
  public var hasChainInfo: Bool {return self._chainInfo != nil}
  /// Clears the value of `chainInfo`. Subsequent reads from it will return its default value.
  public mutating func clearChainInfo() {self._chainInfo = nil}

  /// Whether disable auxiliary random data when signing.
  /// Use for testing **ONLY**.
  public var dangerousUseFixedSchnorrRng: Bool = false

  /// The transaction signing type.
  public var transaction: TW_BitcoinV2_Proto_SigningInput.OneOf_Transaction? = nil

  /// Build a transaction to be signed.
  public var builder: TW_BitcoinV2_Proto_TransactionBuilder {
    get {
      if case .builder(let v)? = transaction {return v}
      return TW_BitcoinV2_Proto_TransactionBuilder()
    }
    set {transaction = .builder(newValue)}
  }

  /// Finalize a Partially Signed Bitcoin Transaction by signing the rest of UTXOs.
  public var psbt: TW_BitcoinV2_Proto_Psbt {
    get {
      if case .psbt(let v)? = transaction {return v}
      return TW_BitcoinV2_Proto_Psbt()
    }
    set {transaction = .psbt(newValue)}
  }

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  /// The transaction signing type.
  public enum OneOf_Transaction: Equatable {
    /// Build a transaction to be signed.
    case builder(TW_BitcoinV2_Proto_TransactionBuilder)
    /// Finalize a Partially Signed Bitcoin Transaction by signing the rest of UTXOs.
    case psbt(TW_BitcoinV2_Proto_Psbt)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_SigningInput.OneOf_Transaction, rhs: TW_BitcoinV2_Proto_SigningInput.OneOf_Transaction) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.builder, .builder): return {
        guard case .builder(let l) = lhs, case .builder(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.psbt, .psbt): return {
        guard case .psbt(let l) = lhs, case .psbt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _chainInfo: TW_BitcoinV2_Proto_ChainInfo? = nil
}

public struct TW_BitcoinV2_Proto_TransactionPlan {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  /// A possible error, `OK` if none.
  public var error: TW_Common_Proto_SigningError = .ok

  /// Error description.
  public var errorMessage: String = String()

  /// Selected unspent transaction outputs (subset of all input UTXOs).
  public var inputs: [TW_BitcoinV2_Proto_Input] = []

  /// Transaction outputs including a change output if applied.
  public var outputs: [TW_BitcoinV2_Proto_Output] = []

  /// Maximum available amount in all the transaction input UTXOs.
  /// That is an amount that will be spent by this transaction.
  public var availableAmount: Int64 = 0

  /// Total sending amount in all the transaction outputs.
  /// That is an amount that will be sent (including change output if applied).
  public var sendAmount: Int64 = 0

  /// The estimated `vsize` in `vbytes`.
  /// It is used to compare how much blockweight needs to be allocated to confirm a transaction.
  /// For non-segwit transactions, `vsize` = `size`.
  public var vsizeEstimate: UInt64 = 0

  /// The estimated fees of the transaction in satoshis.
  public var feeEstimate: Int64 = 0

  /// Remaining change.
  /// Zero if not applied.
  public var change: Int64 = 0

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_BitcoinV2_Proto_PreSigningOutput {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  /// A possible error, `OK` if none.
  public var error: TW_Common_Proto_SigningError = .ok

  /// Error description.
  public var errorMessage: String = String()

  /// The sighashes to be signed; ECDSA for legacy and Segwit, Schnorr for Taproot.
  public var sighashes: [TW_BitcoinV2_Proto_PreSigningOutput.Sighash] = []

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  public enum SigningMethod: VSwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Used for P2SH and P2PKH - standard ecdsa secp256k1 signing
    case legacy // = 0

    /// Used for P2WSH and P2WPKH - standard ecdsa secp256k1 signing
    case segwit // = 1

    /// Used for P2TR key-path and P2TR script-pay - schnorr signing
    case taproot // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .legacy
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .legacy
      case 1: self = .segwit
      case 2: self = .taproot
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .legacy: return 0
      case .segwit: return 1
      case .taproot: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Sighash {
    // VSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
    // methods supported on all messages.

    /// Public key used for signing.
    /// Please note it can be tweaked in case of P2TR scriptPubkey.
    public var publicKey: Data = Data()

    /// The sighash to be signed.
    public var sighash: Data = Data()

    /// Signing method to be used to sign the sighash.
    public var signingMethod: TW_BitcoinV2_Proto_PreSigningOutput.SigningMethod = .legacy

    /// Taproot tweak if `Taproot` signing method is used.
    /// Empty if there is no need to tweak the private to sign the sighash.
    public var tweak: TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak {
      get {return _tweak ?? TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak()}
      set {_tweak = newValue}
    }
    /// Returns true if `tweak` has been explicitly set.
    public var hasTweak: Bool {return self._tweak != nil}
    /// Clears the value of `tweak`. Subsequent reads from it will return its default value.
    public mutating func clearTweak() {self._tweak = nil}

    public var unknownFields = VSwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _tweak: TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak? = nil
  }

  public struct TaprootTweak {
    // VSwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
    // methods supported on all messages.

    /// 32 bytes merkle root of the script tree.
    /// Empty if there are no scripts, and the private key should be tweaked without a merkle root.
    public var merkleRoot: Data = Data()

    public var unknownFields = VSwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension TW_BitcoinV2_Proto_PreSigningOutput.SigningMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_BitcoinV2_Proto_PreSigningOutput.SigningMethod] = [
    .legacy,
    .segwit,
    .taproot,
  ]
}

#endif  // swift(>=4.2)

public struct TW_BitcoinV2_Proto_SigningOutput {
  // VSwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the VSwiftProtobuf library for
  // methods supported on all messages.

  /// A possible error, `OK` if none.
  public var error: TW_Common_Proto_SigningError = .ok

  /// Error description.
  public var errorMessage: String = String()

  /// The encoded transaction that can be submitted to the network.
  public var encoded: Data = Data()

  /// The transaction ID (hash).
  public var txid: Data = Data()

  /// The total `vsize` in `vbytes`.
  /// It is used to compare how much blockweight needs to be allocated to confirm a transaction.
  /// For non-segwit transactions, `vsize` = `size`.
  public var vsize: UInt64 = 0

  /// Transaction weight is defined as Base transaction size * 3 + Total transaction size
  /// (ie. the same method as calculating Block weight from Base size and Total size).
  public var weight: UInt64 = 0

  /// The total and final fee of the transaction in satoshis.
  public var fee: Int64 = 0

  /// Optional. Signed transaction serialized as PSBT.
  /// Set if `SigningInput.psbt` is used.
  public var psbt: TW_BitcoinV2_Proto_Psbt {
    get {return _psbt ?? TW_BitcoinV2_Proto_Psbt()}
    set {_psbt = newValue}
  }
  /// Returns true if `psbt` has been explicitly set.
  public var hasPsbt: Bool {return self._psbt != nil}
  /// Clears the value of `psbt`. Subsequent reads from it will return its default value.
  public mutating func clearPsbt() {self._psbt = nil}

  /// Resulting transaction.
  public var transaction: TW_BitcoinV2_Proto_SigningOutput.OneOf_Transaction? = nil

  /// Standard Bitcoin transaction.
  public var bitcoin: TW_Utxo_Proto_Transaction {
    get {
      if case .bitcoin(let v)? = transaction {return v}
      return TW_Utxo_Proto_Transaction()
    }
    set {transaction = .bitcoin(newValue)}
  }

  /// ZCash transaction.
  public var zcash: TW_Zcash_Proto_Transaction {
    get {
      if case .zcash(let v)? = transaction {return v}
      return TW_Zcash_Proto_Transaction()
    }
    set {transaction = .zcash(newValue)}
  }

  public var unknownFields = VSwiftProtobuf.UnknownStorage()

  /// Resulting transaction.
  public enum OneOf_Transaction: Equatable {
    /// Standard Bitcoin transaction.
    case bitcoin(TW_Utxo_Proto_Transaction)
    /// ZCash transaction.
    case zcash(TW_Zcash_Proto_Transaction)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_BitcoinV2_Proto_SigningOutput.OneOf_Transaction, rhs: TW_BitcoinV2_Proto_SigningOutput.OneOf_Transaction) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.bitcoin, .bitcoin): return {
        guard case .bitcoin(let l) = lhs, case .bitcoin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.zcash, .zcash): return {
        guard case .zcash(let l) = lhs, case .zcash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _psbt: TW_BitcoinV2_Proto_Psbt? = nil
}

// MARK: - Code below here is support for the VSwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.BitcoinV2.Proto"

extension TW_BitcoinV2_Proto_InputSelector: VSwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    0: .same(proto: "SelectAscending"),
    1: .same(proto: "SelectInOrder"),
    2: .same(proto: "SelectDescending"),
    10: .same(proto: "UseAll"),
  ]
}

extension TW_BitcoinV2_Proto_TransactionVersion: VSwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    0: .same(proto: "UseDefault"),
    1: .same(proto: "V1"),
    2: .same(proto: "V2"),
  ]
}

extension TW_BitcoinV2_Proto_PublicKeyOrHash: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKeyOrHash"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .pubkey(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .hash(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .pubkey?: try {
      guard case .pubkey(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .hash?: try {
      guard case .hash(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_PublicKeyOrHash, rhs: TW_BitcoinV2_Proto_PublicKeyOrHash) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_PublicKeySignature: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKeySignature"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_PublicKeySignature, rhs: TW_BitcoinV2_Proto_PublicKeySignature) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Input: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Input"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .standard(proto: "out_point"),
    2: .same(proto: "value"),
    3: .standard(proto: "sighash_type"),
    4: .same(proto: "sequence"),
    5: .standard(proto: "script_builder"),
    6: .standard(proto: "script_data"),
    7: .standard(proto: "receiver_address"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outPoint) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.sighashType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._sequence) }()
      case 5: try {
        var v: TW_BitcoinV2_Proto_Input.InputBuilder?
        var hadOneofValue = false
        if let current = self.claimingScript {
          hadOneofValue = true
          if case .scriptBuilder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.claimingScript = .scriptBuilder(v)
        }
      }()
      case 6: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.claimingScript != nil {try decoder.handleConflictingOneOf()}
          self.claimingScript = .scriptData(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.claimingScript != nil {try decoder.handleConflictingOneOf()}
          self.claimingScript = .receiverAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    if self.sighashType != 0 {
      try visitor.visitSingularUInt32Field(value: self.sighashType, fieldNumber: 3)
    }
    try { if let v = self._sequence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.claimingScript {
    case .scriptBuilder?: try {
      guard case .scriptBuilder(let v)? = self.claimingScript else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .scriptData?: try {
      guard case .scriptData(let v)? = self.claimingScript else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }()
    case .receiverAddress?: try {
      guard case .receiverAddress(let v)? = self.claimingScript else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Input, rhs: TW_BitcoinV2_Proto_Input) -> Bool {
    if lhs._outPoint != rhs._outPoint {return false}
    if lhs.value != rhs.value {return false}
    if lhs.sighashType != rhs.sighashType {return false}
    if lhs._sequence != rhs._sequence {return false}
    if lhs.claimingScript != rhs.claimingScript {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Input.Sequence: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Input.protoMessageName + ".Sequence"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .same(proto: "sequence"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sequence) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sequence != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequence, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Input.Sequence, rhs: TW_BitcoinV2_Proto_Input.Sequence) -> Bool {
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Input.InputBuilder: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Input.protoMessageName + ".InputBuilder"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    2: .same(proto: "p2pk"),
    3: .same(proto: "p2pkh"),
    5: .same(proto: "p2wpkh"),
    7: .standard(proto: "p2tr_key_path"),
    9: .standard(proto: "brc20_inscribe"),
    15: .standard(proto: "babylon_staking_timelock_path"),
    16: .standard(proto: "babylon_staking_unbonding_path"),
    17: .standard(proto: "babylon_staking_slashing_path"),
    18: .standard(proto: "babylon_unbonding_timelock_path"),
    19: .standard(proto: "babylon_unbonding_slashing_path"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .p2Pk(v)
        }
      }()
      case 3: try {
        var v: TW_BitcoinV2_Proto_PublicKeyOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Pkh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Pkh(v)
        }
      }()
      case 5: try {
        var v: TW_BitcoinV2_Proto_PublicKeyOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Wpkh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Wpkh(v)
        }
      }()
      case 7: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .p2TrKeyPath(v)
        }
      }()
      case 9: try {
        var v: TW_BitcoinV2_Proto_Input.InputBrc20Inscription?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .brc20Inscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .brc20Inscribe(v)
        }
      }()
      case 15: try {
        var v: TW_BabylonStaking_Proto_InputBuilder.StakingTimelockPath?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .babylonStakingTimelockPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .babylonStakingTimelockPath(v)
        }
      }()
      case 16: try {
        var v: TW_BabylonStaking_Proto_InputBuilder.StakingUnbondingPath?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .babylonStakingUnbondingPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .babylonStakingUnbondingPath(v)
        }
      }()
      case 17: try {
        var v: TW_BabylonStaking_Proto_InputBuilder.StakingSlashingPath?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .babylonStakingSlashingPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .babylonStakingSlashingPath(v)
        }
      }()
      case 18: try {
        var v: TW_BabylonStaking_Proto_InputBuilder.UnbondingTimelockPath?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .babylonUnbondingTimelockPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .babylonUnbondingTimelockPath(v)
        }
      }()
      case 19: try {
        var v: TW_BabylonStaking_Proto_InputBuilder.UnbondingSlashingPath?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .babylonUnbondingSlashingPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .babylonUnbondingSlashingPath(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .p2Pk?: try {
      guard case .p2Pk(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .p2Pkh?: try {
      guard case .p2Pkh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .p2Wpkh?: try {
      guard case .p2Wpkh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .p2TrKeyPath?: try {
      guard case .p2TrKeyPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }()
    case .brc20Inscribe?: try {
      guard case .brc20Inscribe(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .babylonStakingTimelockPath?: try {
      guard case .babylonStakingTimelockPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .babylonStakingUnbondingPath?: try {
      guard case .babylonStakingUnbondingPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .babylonStakingSlashingPath?: try {
      guard case .babylonStakingSlashingPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .babylonUnbondingTimelockPath?: try {
      guard case .babylonUnbondingTimelockPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .babylonUnbondingSlashingPath?: try {
      guard case .babylonUnbondingSlashingPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Input.InputBuilder, rhs: TW_BitcoinV2_Proto_Input.InputBuilder) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Input.InputTaprootScriptPath: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Input.protoMessageName + ".InputTaprootScriptPath"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    2: .same(proto: "payload"),
    3: .standard(proto: "control_block"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.controlBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.controlBlock.isEmpty {
      try visitor.visitSingularBytesField(value: self.controlBlock, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Input.InputTaprootScriptPath, rhs: TW_BitcoinV2_Proto_Input.InputTaprootScriptPath) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.controlBlock != rhs.controlBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Input.InputBrc20Inscription: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Input.protoMessageName + ".InputBrc20Inscription"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    2: .standard(proto: "inscribe_to"),
    3: .same(proto: "ticker"),
    4: .standard(proto: "transfer_amount"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.inscribeTo) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.transferAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inscribeTo.isEmpty {
      try visitor.visitSingularBytesField(value: self.inscribeTo, fieldNumber: 2)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 3)
    }
    if !self.transferAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.transferAmount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Input.InputBrc20Inscription, rhs: TW_BitcoinV2_Proto_Input.InputBrc20Inscription) -> Bool {
    if lhs.inscribeTo != rhs.inscribeTo {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.transferAmount != rhs.transferAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Output: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Output"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "builder"),
    3: .standard(proto: "custom_script_pubkey"),
    4: .standard(proto: "to_address"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      case 2: try {
        var v: TW_BitcoinV2_Proto_Output.OutputBuilder?
        var hadOneofValue = false
        if let current = self.toRecipient {
          hadOneofValue = true
          if case .builder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.toRecipient = .builder(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.toRecipient != nil {try decoder.handleConflictingOneOf()}
          self.toRecipient = .customScriptPubkey(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.toRecipient != nil {try decoder.handleConflictingOneOf()}
          self.toRecipient = .toAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    switch self.toRecipient {
    case .builder?: try {
      guard case .builder(let v)? = self.toRecipient else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .customScriptPubkey?: try {
      guard case .customScriptPubkey(let v)? = self.toRecipient else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .toAddress?: try {
      guard case .toAddress(let v)? = self.toRecipient else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Output, rhs: TW_BitcoinV2_Proto_Output) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.toRecipient != rhs.toRecipient {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Output.OutputBuilder: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Output.protoMessageName + ".OutputBuilder"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .same(proto: "p2sh"),
    2: .same(proto: "p2pk"),
    3: .same(proto: "p2pkh"),
    4: .same(proto: "p2wsh"),
    5: .same(proto: "p2wpkh"),
    6: .standard(proto: "p2tr_key_path"),
    7: .standard(proto: "p2tr_script_path"),
    8: .standard(proto: "p2tr_dangerous_assume_tweaked"),
    9: .standard(proto: "brc20_inscribe"),
    12: .standard(proto: "op_return"),
    15: .standard(proto: "babylon_staking"),
    16: .standard(proto: "babylon_unbonding"),
    17: .standard(proto: "babylon_staking_op_return"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Sh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Sh(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .p2Pk(v)
        }
      }()
      case 3: try {
        var v: TW_BitcoinV2_Proto_PublicKeyOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Pkh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Pkh(v)
        }
      }()
      case 4: try {
        var v: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Wsh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Wsh(v)
        }
      }()
      case 5: try {
        var v: TW_BitcoinV2_Proto_PublicKeyOrHash?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2Wpkh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2Wpkh(v)
        }
      }()
      case 6: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .p2TrKeyPath(v)
        }
      }()
      case 7: try {
        var v: TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .p2TrScriptPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .p2TrScriptPath(v)
        }
      }()
      case 8: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .p2TrDangerousAssumeTweaked(v)
        }
      }()
      case 9: try {
        var v: TW_BitcoinV2_Proto_Output.OutputBrc20Inscription?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .brc20Inscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .brc20Inscribe(v)
        }
      }()
      case 12: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .opReturn(v)
        }
      }()
      case 15: try {
        var v: TW_BabylonStaking_Proto_OutputBuilder.StakingOutput?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .babylonStaking(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .babylonStaking(v)
        }
      }()
      case 16: try {
        var v: TW_BabylonStaking_Proto_OutputBuilder.UnbondingOutput?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .babylonUnbonding(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .babylonUnbonding(v)
        }
      }()
      case 17: try {
        var v: TW_BabylonStaking_Proto_OutputBuilder.OpReturn?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .babylonStakingOpReturn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .babylonStakingOpReturn(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .p2Sh?: try {
      guard case .p2Sh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .p2Pk?: try {
      guard case .p2Pk(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .p2Pkh?: try {
      guard case .p2Pkh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .p2Wsh?: try {
      guard case .p2Wsh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .p2Wpkh?: try {
      guard case .p2Wpkh(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .p2TrKeyPath?: try {
      guard case .p2TrKeyPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }()
    case .p2TrScriptPath?: try {
      guard case .p2TrScriptPath(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .p2TrDangerousAssumeTweaked?: try {
      guard case .p2TrDangerousAssumeTweaked(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }()
    case .brc20Inscribe?: try {
      guard case .brc20Inscribe(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .opReturn?: try {
      guard case .opReturn(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 12)
    }()
    case .babylonStaking?: try {
      guard case .babylonStaking(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .babylonUnbonding?: try {
      guard case .babylonUnbonding(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .babylonStakingOpReturn?: try {
      guard case .babylonStakingOpReturn(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Output.OutputBuilder, rhs: TW_BitcoinV2_Proto_Output.OutputBuilder) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Output.RedeemScriptOrHash: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Output.protoMessageName + ".RedeemScriptOrHash"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .standard(proto: "redeem_script"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .redeemScript(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .hash(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .redeemScript?: try {
      guard case .redeemScript(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .hash?: try {
      guard case .hash(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash, rhs: TW_BitcoinV2_Proto_Output.RedeemScriptOrHash) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Output.protoMessageName + ".OutputTaprootScriptPath"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .standard(proto: "internal_key"),
    2: .standard(proto: "merkle_root"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.internalKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.merkleRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.internalKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.internalKey, fieldNumber: 1)
    }
    if !self.merkleRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.merkleRoot, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath, rhs: TW_BitcoinV2_Proto_Output.OutputTaprootScriptPath) -> Bool {
    if lhs.internalKey != rhs.internalKey {return false}
    if lhs.merkleRoot != rhs.merkleRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Output.OutputBrc20Inscription: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_Output.protoMessageName + ".OutputBrc20Inscription"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .standard(proto: "inscribe_to"),
    2: .same(proto: "ticker"),
    3: .standard(proto: "transfer_amount"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.inscribeTo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ticker) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transferAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inscribeTo.isEmpty {
      try visitor.visitSingularBytesField(value: self.inscribeTo, fieldNumber: 1)
    }
    if !self.ticker.isEmpty {
      try visitor.visitSingularStringField(value: self.ticker, fieldNumber: 2)
    }
    if !self.transferAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.transferAmount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Output.OutputBrc20Inscription, rhs: TW_BitcoinV2_Proto_Output.OutputBrc20Inscription) -> Bool {
    if lhs.inscribeTo != rhs.inscribeTo {return false}
    if lhs.ticker != rhs.ticker {return false}
    if lhs.transferAmount != rhs.transferAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_ChainInfo: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChainInfo"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .standard(proto: "p2pkh_prefix"),
    2: .standard(proto: "p2sh_prefix"),
    3: .same(proto: "hrp"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.p2PkhPrefix) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.p2ShPrefix) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hrp) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.p2PkhPrefix != 0 {
      try visitor.visitSingularUInt32Field(value: self.p2PkhPrefix, fieldNumber: 1)
    }
    if self.p2ShPrefix != 0 {
      try visitor.visitSingularUInt32Field(value: self.p2ShPrefix, fieldNumber: 2)
    }
    if !self.hrp.isEmpty {
      try visitor.visitSingularStringField(value: self.hrp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_ChainInfo, rhs: TW_BitcoinV2_Proto_ChainInfo) -> Bool {
    if lhs.p2PkhPrefix != rhs.p2PkhPrefix {return false}
    if lhs.p2ShPrefix != rhs.p2ShPrefix {return false}
    if lhs.hrp != rhs.hrp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_TransactionBuilder: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionBuilder"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "lock_time"),
    3: .same(proto: "inputs"),
    4: .same(proto: "outputs"),
    5: .standard(proto: "input_selector"),
    6: .standard(proto: "fee_per_vb"),
    7: .standard(proto: "change_output"),
    8: .standard(proto: "max_amount_output"),
    10: .standard(proto: "fixed_dust_threshold"),
    20: .standard(proto: "zcash_extra_data"),
  ]

  fileprivate class _StorageClass {
    var _version: TW_BitcoinV2_Proto_TransactionVersion = .useDefault
    var _lockTime: UInt32 = 0
    var _inputs: [TW_BitcoinV2_Proto_Input] = []
    var _outputs: [TW_BitcoinV2_Proto_Output] = []
    var _inputSelector: TW_BitcoinV2_Proto_InputSelector = .selectAscending
    var _feePerVb: Int64 = 0
    var _changeOutput: TW_BitcoinV2_Proto_Output? = nil
    var _maxAmountOutput: TW_BitcoinV2_Proto_Output? = nil
    var _dustPolicy: TW_BitcoinV2_Proto_TransactionBuilder.OneOf_DustPolicy?
    var _chainSpecific: TW_BitcoinV2_Proto_TransactionBuilder.OneOf_ChainSpecific?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _lockTime = source._lockTime
      _inputs = source._inputs
      _outputs = source._outputs
      _inputSelector = source._inputSelector
      _feePerVb = source._feePerVb
      _changeOutput = source._changeOutput
      _maxAmountOutput = source._maxAmountOutput
      _dustPolicy = source._dustPolicy
      _chainSpecific = source._chainSpecific
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._lockTime) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._inputs) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._outputs) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._inputSelector) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._feePerVb) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._changeOutput) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._maxAmountOutput) }()
        case 10: try {
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {
            if _storage._dustPolicy != nil {try decoder.handleConflictingOneOf()}
            _storage._dustPolicy = .fixedDustThreshold(v)
          }
        }()
        case 20: try {
          var v: TW_Zcash_Proto_TransactionBuilderExtraData?
          var hadOneofValue = false
          if let current = _storage._chainSpecific {
            hadOneofValue = true
            if case .zcashExtraData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._chainSpecific = .zcashExtraData(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._version != .useDefault {
        try visitor.visitSingularEnumField(value: _storage._version, fieldNumber: 1)
      }
      if _storage._lockTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lockTime, fieldNumber: 2)
      }
      if !_storage._inputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inputs, fieldNumber: 3)
      }
      if !_storage._outputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._outputs, fieldNumber: 4)
      }
      if _storage._inputSelector != .selectAscending {
        try visitor.visitSingularEnumField(value: _storage._inputSelector, fieldNumber: 5)
      }
      if _storage._feePerVb != 0 {
        try visitor.visitSingularInt64Field(value: _storage._feePerVb, fieldNumber: 6)
      }
      try { if let v = _storage._changeOutput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._maxAmountOutput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if case .fixedDustThreshold(let v)? = _storage._dustPolicy {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 10)
      } }()
      try { if case .zcashExtraData(let v)? = _storage._chainSpecific {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_TransactionBuilder, rhs: TW_BitcoinV2_Proto_TransactionBuilder) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._lockTime != rhs_storage._lockTime {return false}
        if _storage._inputs != rhs_storage._inputs {return false}
        if _storage._outputs != rhs_storage._outputs {return false}
        if _storage._inputSelector != rhs_storage._inputSelector {return false}
        if _storage._feePerVb != rhs_storage._feePerVb {return false}
        if _storage._changeOutput != rhs_storage._changeOutput {return false}
        if _storage._maxAmountOutput != rhs_storage._maxAmountOutput {return false}
        if _storage._dustPolicy != rhs_storage._dustPolicy {return false}
        if _storage._chainSpecific != rhs_storage._chainSpecific {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_Psbt: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Psbt"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.psbt) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.psbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.psbt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_Psbt, rhs: TW_BitcoinV2_Proto_Psbt) -> Bool {
    if lhs.psbt != rhs.psbt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_SigningInput: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningInput"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .standard(proto: "private_keys"),
    2: .standard(proto: "public_keys"),
    3: .standard(proto: "chain_info"),
    4: .standard(proto: "dangerous_use_fixed_schnorr_rng"),
    10: .same(proto: "builder"),
    11: .same(proto: "psbt"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.privateKeys) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.publicKeys) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._chainInfo) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.dangerousUseFixedSchnorrRng) }()
      case 10: try {
        var v: TW_BitcoinV2_Proto_TransactionBuilder?
        var hadOneofValue = false
        if let current = self.transaction {
          hadOneofValue = true
          if case .builder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transaction = .builder(v)
        }
      }()
      case 11: try {
        var v: TW_BitcoinV2_Proto_Psbt?
        var hadOneofValue = false
        if let current = self.transaction {
          hadOneofValue = true
          if case .psbt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transaction = .psbt(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.privateKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.privateKeys, fieldNumber: 1)
    }
    if !self.publicKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.publicKeys, fieldNumber: 2)
    }
    try { if let v = self._chainInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.dangerousUseFixedSchnorrRng != false {
      try visitor.visitSingularBoolField(value: self.dangerousUseFixedSchnorrRng, fieldNumber: 4)
    }
    switch self.transaction {
    case .builder?: try {
      guard case .builder(let v)? = self.transaction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .psbt?: try {
      guard case .psbt(let v)? = self.transaction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_SigningInput, rhs: TW_BitcoinV2_Proto_SigningInput) -> Bool {
    if lhs.privateKeys != rhs.privateKeys {return false}
    if lhs.publicKeys != rhs.publicKeys {return false}
    if lhs._chainInfo != rhs._chainInfo {return false}
    if lhs.dangerousUseFixedSchnorrRng != rhs.dangerousUseFixedSchnorrRng {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_TransactionPlan: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionPlan"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "error_message"),
    3: .same(proto: "inputs"),
    4: .same(proto: "outputs"),
    5: .standard(proto: "available_amount"),
    6: .standard(proto: "send_amount"),
    7: .standard(proto: "vsize_estimate"),
    8: .standard(proto: "fee_estimate"),
    9: .same(proto: "change"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.availableAmount) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.sendAmount) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.vsizeEstimate) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.feeEstimate) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.change) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 3)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 4)
    }
    if self.availableAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.availableAmount, fieldNumber: 5)
    }
    if self.sendAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.sendAmount, fieldNumber: 6)
    }
    if self.vsizeEstimate != 0 {
      try visitor.visitSingularUInt64Field(value: self.vsizeEstimate, fieldNumber: 7)
    }
    if self.feeEstimate != 0 {
      try visitor.visitSingularInt64Field(value: self.feeEstimate, fieldNumber: 8)
    }
    if self.change != 0 {
      try visitor.visitSingularInt64Field(value: self.change, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_TransactionPlan, rhs: TW_BitcoinV2_Proto_TransactionPlan) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.availableAmount != rhs.availableAmount {return false}
    if lhs.sendAmount != rhs.sendAmount {return false}
    if lhs.vsizeEstimate != rhs.vsizeEstimate {return false}
    if lhs.feeEstimate != rhs.feeEstimate {return false}
    if lhs.change != rhs.change {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_PreSigningOutput: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreSigningOutput"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "error_message"),
    4: .same(proto: "sighashes"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sighashes) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    if !self.sighashes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sighashes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_PreSigningOutput, rhs: TW_BitcoinV2_Proto_PreSigningOutput) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.sighashes != rhs.sighashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_PreSigningOutput.SigningMethod: VSwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    0: .same(proto: "Legacy"),
    1: .same(proto: "Segwit"),
    2: .same(proto: "Taproot"),
  ]
}

extension TW_BitcoinV2_Proto_PreSigningOutput.Sighash: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_PreSigningOutput.protoMessageName + ".Sighash"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "sighash"),
    3: .standard(proto: "signing_method"),
    4: .same(proto: "tweak"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sighash) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.signingMethod) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tweak) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.sighash.isEmpty {
      try visitor.visitSingularBytesField(value: self.sighash, fieldNumber: 2)
    }
    if self.signingMethod != .legacy {
      try visitor.visitSingularEnumField(value: self.signingMethod, fieldNumber: 3)
    }
    try { if let v = self._tweak {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_PreSigningOutput.Sighash, rhs: TW_BitcoinV2_Proto_PreSigningOutput.Sighash) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.sighash != rhs.sighash {return false}
    if lhs.signingMethod != rhs.signingMethod {return false}
    if lhs._tweak != rhs._tweak {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_BitcoinV2_Proto_PreSigningOutput.protoMessageName + ".TaprootTweak"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .standard(proto: "merkle_root"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.merkleRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.merkleRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.merkleRoot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak, rhs: TW_BitcoinV2_Proto_PreSigningOutput.TaprootTweak) -> Bool {
    if lhs.merkleRoot != rhs.merkleRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_BitcoinV2_Proto_SigningOutput: VSwiftProtobuf.Message, VSwiftProtobuf._MessageImplementationBase, VSwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningOutput"
  public static let _protobuf_nameMap: VSwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "error_message"),
    4: .same(proto: "encoded"),
    5: .same(proto: "txid"),
    6: .same(proto: "vsize"),
    7: .same(proto: "weight"),
    8: .same(proto: "fee"),
    9: .same(proto: "psbt"),
    15: .same(proto: "bitcoin"),
    16: .same(proto: "zcash"),
  ]

  public mutating func decodeMessage<D: VSwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.encoded) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.vsize) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.weight) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.fee) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._psbt) }()
      case 15: try {
        var v: TW_Utxo_Proto_Transaction?
        var hadOneofValue = false
        if let current = self.transaction {
          hadOneofValue = true
          if case .bitcoin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transaction = .bitcoin(v)
        }
      }()
      case 16: try {
        var v: TW_Zcash_Proto_Transaction?
        var hadOneofValue = false
        if let current = self.transaction {
          hadOneofValue = true
          if case .zcash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transaction = .zcash(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: VSwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    if !self.encoded.isEmpty {
      try visitor.visitSingularBytesField(value: self.encoded, fieldNumber: 4)
    }
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 5)
    }
    if self.vsize != 0 {
      try visitor.visitSingularUInt64Field(value: self.vsize, fieldNumber: 6)
    }
    if self.weight != 0 {
      try visitor.visitSingularUInt64Field(value: self.weight, fieldNumber: 7)
    }
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 8)
    }
    try { if let v = self._psbt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    switch self.transaction {
    case .bitcoin?: try {
      guard case .bitcoin(let v)? = self.transaction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .zcash?: try {
      guard case .zcash(let v)? = self.transaction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_BitcoinV2_Proto_SigningOutput, rhs: TW_BitcoinV2_Proto_SigningOutput) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.encoded != rhs.encoded {return false}
    if lhs.txid != rhs.txid {return false}
    if lhs.vsize != rhs.vsize {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs._psbt != rhs._psbt {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
